exception DiaSyntaxError of string

let dia_dbgprint str =
  Printf.eprintf "[dia.ml] %s\n" str

let rec treemaker chr depth =
  match depth with
  | 0 -> " "
  | _ -> chr ^ treemaker chr (depth - 1)

let debug_type_to_string (t: DiaNode.dia_token_type) =
  match t with
  | DiaFunction _ -> "DiaFunction"
  | DiaFunctionParam _ -> "DiaFunctionParam"
  | DiaConstant _ -> "DiaConstant"

(* I tried
 * match t with
 * | _ DiaInteger -> ...
 * | _ DiaString -> ...
 * | _ DiaDouble -> ...
 * | _ DiaBool -> ...
 * | _ DiaVoid -> ...
 * But it didn't work.
 *)
let type_to_string (t: DiaNode.dia_token_type) =
  match t with
  | DiaConstant DiaInteger -> "int"
  | DiaConstant DiaString -> "std::string"
  | DiaConstant DiaDouble -> "double"
  | DiaConstant DiaBool -> "bool"
  | DiaConstant DiaVoid -> "void"
  | DiaFunction DiaInteger -> "int"
  | DiaFunction DiaString -> "std::string"
  | DiaFunction DiaDouble -> "double"
  | DiaFunction DiaBool -> "bool"
  | DiaFunction DiaVoid -> "void"
  | DiaFunctionParam DiaInteger -> "int"
  | DiaFunctionParam DiaString -> "std::string"
  | DiaFunctionParam DiaDouble -> "double"
  | DiaFunctionParam DiaBool -> "bool"
  | DiaFunctionParam DiaVoid -> "void"

let rec dia_debug_function_descriptor (node : DiaNode.dia_node) depth: unit =
  Printf.eprintf "%sname: %s\n" (treemaker "-" depth) node.name;
  Printf.eprintf "%stoken_type: %s\n" 
    (treemaker "-" depth) (debug_type_to_string node.token_type);
  Printf.eprintf "%snum_of_parameters: %d\n" (treemaker "-" depth) node.num_of_parameters;
  Printf.eprintf "%sParameters:\n" (treemaker "-" depth);
  List.iter (fun e -> dia_debug_function_descriptor e (depth+1)) node.parameters

let generate_header = "\n\
  /* Start of Main function */\n\
  int main(int argc, char** argv) {\n\
"

(*
 String.split_on_char '|' "ab|cd|ef|gh" |> List.fold_left (fun x acc -> x ^ "\n * " ^  acc) "";;
 - : string = "\n * ab\n * cd\n * ef\n * gh"
*)
let generate_comment (orig_code: string) = "/**\
  * This code is generated by diac, the Dia programming language compiler.\n\
  * Version Info:\n\
  * Original Source Code:\n\
  * ```dia\n\
  * "
  ^ orig_code ^
  "\n\
  * ```\n\
  *\n\
*/"

(* In C, it was a static function, a simple counter function.
 * In each function call, it just returns "v0", "v1", ...
 * But it is cumbersome in OCaml, and it was also hard to fine-tune
 * these C++ variables.
 *)
let dia_create_cpp_variable (i: int) =
  Printf.sprintf "v%d" i

let rec dia_generate_code (node: DiaNode.dia_node) (custom_functions: DiaNode.dia_node list) (var_index: int): DiaNode.dia_node * int =
  if node.name = "if"
  then dia_if node custom_functions var_index
  else match node.token_type with
    | DiaConstant _ -> node, var_index
    | DiaFunctionParam _ -> (
        dia_dbgprint (Printf.sprintf "Function parameter '%s' detected" node.name);
        node, var_index
      )
    | DiaFunction _ ->
      dia_dbgprint (Printf.sprintf "Generating code for function '%s'"  node.name);
      dia_debug_function_descriptor node 0;
      (* Evaluate the parameters first. *)
      let parameters, _var_index = dia_generate_code_parameter node.parameters custom_functions var_index in
      (* Find the node name in custom created function list *)
      let cfunc = List.find_opt
        (fun (e: DiaNode.dia_node) -> e.name = node.name)
        custom_functions
      in
      match cfunc with
      | Some func -> List.map (fun (p: DiaNode.dia_node) -> p.name) parameters
        |> String.concat ","
        |> Printf.printf "auto %s = %s(%s);\n" (dia_create_cpp_variable _var_index) node.name;
        {
          name = dia_create_cpp_variable _var_index;
          token_type = func.token_type;
          num_of_parameters = 0;
          parameters = [];
          next_function = None;
        }, (_var_index + 1)
      | None ->
        (* Find given function name in predefined function list *)
        let pfunc = List.find_opt
          (fun (e: Predefined.dia_predefined_function) -> e.node.name = node.name)
          Predefined.functions
        in
        match pfunc with
        | None -> raise (DiaSyntaxError ("Error: Unknown identifier '" ^ node.name ^ "'. Don't know how to generate it."))
        | Some func -> func.generate_code {
            name = node.name;
            token_type = node.token_type;
            num_of_parameters = node.num_of_parameters;
            parameters = parameters;
            next_function = node.next_function;
          } _var_index

and dia_generate_code_parameter (nodes: DiaNode.dia_node list) (custom_functions: DiaNode.dia_node list) (var_index: int): DiaNode.dia_node list * int =
  match nodes with
  | [] -> ([], var_index)
  | n :: ns ->
    let p, vi = dia_generate_code n custom_functions var_index in
    let ps, i = dia_generate_code_parameter ns custom_functions vi in
    (p :: ps, i)

and dia_if (node: DiaNode.dia_node) (custom_functions: DiaNode.dia_node list) (var_index: int): DiaNode.dia_node * int =
  dia_dbgprint "Generating code of if-else clause";
  let _, _ = dia_if_parse_condition node custom_functions var_index in
  dia_if_parse_bodies node custom_functions var_index

and dia_if_parse_condition (node: DiaNode.dia_node) (custom_functions: DiaNode.dia_node list) (var_index: int): DiaNode.dia_node * int =
  let _, _var_index = dia_generate_code (List.nth node.parameters 0) custom_functions var_index in
  let else_clause = List.nth node.parameters 2 in
  match else_clause.name with
  (* else if (<Condition>) <Dia expression> *)
  | "if" -> dia_if_parse_condition else_clause custom_functions _var_index
  (* else <Dia expression> *)
  | _ -> node, var_index

and dia_if_parse_bodies (node: DiaNode.dia_node) (custom_functions: DiaNode.dia_node list) (var_index: int): DiaNode.dia_node * int =
  let _ = Printf.printf "if(%s){\n" (dia_create_cpp_variable var_index) in
  let _ =
    let _node = List.nth node.parameters 1 in
    match _node.token_type with
    | DiaConstant _ -> Printf.printf "return %s;\n} else " _node.name
    | _ -> let parameters, _var_index = dia_generate_code _node custom_functions var_index in
           Printf.printf "return %s;\n} else " (dia_create_cpp_variable _var_index)
  in
  let _node = List.nth node.parameters 2 in
  if _node.name = "if"
  then dia_if_parse_bodies _node custom_functions (var_index + 1)
  else
    begin
      let _node = List.nth node.parameters 2 in
      match _node.token_type with
      | DiaConstant _ -> Printf.printf "{\nreturn %s;\n}\n" _node.name; node, (var_index + 1)
      | _ -> let _ = print_endline "{" in
             let parameters, _var_index = dia_generate_code _node custom_functions var_index in
             Printf.printf "return %s;\n}\n" (dia_create_cpp_variable _var_index);
             node, (_var_index + 1)
    end

let rec dia_generate_code_chain (node: DiaNode.dia_node) (custom_functions: DiaNode.dia_node list) (var_index: int): DiaNode.dia_node * int =
  let n, i = dia_generate_code node custom_functions var_index in
  match node.next_function with
  | Some next_func ->
    let _n, j = dia_generate_code_chain next_func custom_functions (i+1) in
    (_n, j)
  | None -> (n, i)

let rec dia_debug_function_descriptor_chain (node: DiaNode.dia_node) =
  dia_debug_function_descriptor node 0;
  match node.next_function with
  | None -> ()
  | Some next_node -> dia_debug_function_descriptor_chain next_node


let dia_main (node: DiaNode.dia) orig_code =
  dia_dbgprint "Lemme write down bill of main function...";
  dia_debug_function_descriptor_chain node.main_function;
  dia_dbgprint "Available custom functions are:";
  List.map (fun (cf: DiaNode.dia_node) -> cf.name) node.custom_functions
  |> String.concat ", "
  |> dia_dbgprint;
  (print_endline generate_header);
  (print_endline (generate_comment orig_code));
  let _, _ = dia_generate_code_chain node.main_function node.custom_functions 0 in
  print_string "return 0;\n}\n/* End of Main Function */\n"

let generate_custom_func_header (node: DiaNode.dia_node) =
  Printf.printf "%s %s(" (type_to_string node.token_type) node.name;
  List.map (fun (p: DiaNode.dia_node) -> Printf.sprintf "%s %s" (type_to_string p.token_type) p.name) node.parameters
  |> String.concat ","
  |> print_string;
  print_endline ") {"

let dia_custom_function (node: DiaNode.dia_node) (custom_functions: DiaNode.dia_node list) orig_code =
  match node.next_function with
  | None ->
    Printf.sprintf "Function %s have no function body. Skipping generating code." node.name
    |> dia_dbgprint
  | Some body ->
    dia_dbgprint (Printf.sprintf "Generating code for custom function '%s'" node.name);
    Printf.printf "/* Start of %s Function */\n" node.name;
    generate_custom_func_header node;
    dia_debug_function_descriptor_chain node;
    match body.token_type with
    | DiaConstant _ ->
      print_endline ("return " ^ body.name ^ ";");
      Printf.printf "}\n/* End of %s Function */\n" node.name
    | _ ->
      let _, cpp_var_count = dia_generate_code_chain body custom_functions 0 in
      print_endline ("return v" ^ string_of_int (cpp_var_count - 1) ^ ";");
      Printf.printf "}\n/* End of %s Function */\n" node.name